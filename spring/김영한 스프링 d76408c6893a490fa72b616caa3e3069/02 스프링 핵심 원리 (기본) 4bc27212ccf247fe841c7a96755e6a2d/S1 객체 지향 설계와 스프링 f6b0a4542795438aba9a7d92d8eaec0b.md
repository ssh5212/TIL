# S1 객체 지향 설계와 스프링

---

---

# Spring의 역사

과거

EJB : 비쌈, 느림, 어려움

POJO 단어가 나온 이유

→ Spring과 하이버네이트를 만듦

1) Spring의 탄생

BeanFactory, Application Context

2) 하이버네이트의 탄생

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled.png)

하이버네이트를 만듦 → 잘 되서 JPA라는 표준 인터페이스를 만듦

---

# 스프링 생태계

스프링은 여러 기술의 모음

**핵심**

스프링 프레임워크, 스프링 부트

부트 : 모든 기술들을 편리하게 사용 가능

**기타**

스프링 데이터 : Spring Data JPA 

스프링 세션 

스프링 시크리티 

REST Docs

스프링 배치

스프링 클라우드

**스프링 프레임워크**

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%201.png)

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%202.png)

내장 톰켓을 가지고 있음

하나의 라이브러리를 사용하면 종속되는 나머지 라이브러리를 가져옴

종속적인 외부 라이브러리의 버전을 알아서 정해줌 (최적화)

스프링 부트는 스프링 프레임워크들을 편하게 사용할 수 있도록 함

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%203.png)

---

# 스프링의 핵심 컨셉

- 자바 언어 기반의 프레임워크
- 자바 == 객체 지향 언어
- 스프링은 객체 지향언어가 가진 특징을 살려내는 프레임워크
- 좋은 객체 지향 어플리케이션을 개발할 수 있게 도와주는 프레임워크
- 객체 지향을 쉽게 하도록 도와주는 도구

- EJB는 객체지향의 장점을 살려내지 못했음 (POJO)

---

# 좋은 객체지향 프로그래밍

객체지향 프로그래밍

- 프로그램을 객체들의 모임 형태로 구현
- 객체는 메시지를 주고 받고 데이터를 처리한다
- 프로그램이 유연하고 변경이 용이해짐

추상화, 캡슐화, 상속, 다형성 

다형성 : 변경이 용이한 방법, 객체 지향 핵심

## 다형성

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%204.png)

자동차가 바뀌어도 운전자는 운전을 할 수 있음

자동차 내부가 바뀌거나 자동차 자체가 바뀌어도 클라이언트(운전자는) 그대로 사용할 수 있음

클라이언트에 영향을 주지 않고 새로운 기능을 추가할 수 있음

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%205.png)

역할은 누구나 변경이 가능하다

로미오를 누가하든 줄리엣은 상관이 없다

역할과 구현을 분리 했을 떄의 장점

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%206.png)

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%207.png)

역할인 인터페이스를 먼저 구현하고 이를 구현

구현보다 인터페이스(역할)을 먼저 정의한다

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%208.png)

객체는 항상 요청과 응답이 있음

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%209.png)

오버 라이딩 : 기능을 넘어서 재정의했다

오버 로딩 : 초과해서 로딩 했다 == 메소드를 많이 정의 했다

다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%2010.png)

부모 타입으로 모든 자식을 다 받아들일 수 있음

다형성의 본질

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%2011.png)

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%2012.png)

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%2013.png)

인터페이스가 변경되지 않도록 안정적으로(범용적으로) 잘 구현하는 것이 중요함

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%2014.png)

---

# 좋은 객체 지향 설계의 5개 원칙 (SOLID)

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%2015.png)

1) 단일 책임 원칙

- 하나의 클래스는 하나의 책임을 가져야 한다
- 하지만 하나의 책임은 크기, 문맥, 상황에 따라 모호함
- 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
- 하나의 변경이 있을 때 하나의 코드만 수정하면 단일 책임 원칙을 잘 따른 것

2) 개방 폐쇄 원칙

- 확장에는 열려 있으나 변경에는 닫혀있어야 함
- 코드의 변경없이 기능을 추가 → 다형성을 통해서
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현 (기존 코드의 변경은 이뤄지지 않음)
- 구현 객체를 변경하려면 클라이언트 변경이 필요함 (개방 폐쇄 원칙 자체가 깨질 수 있음)
- 객체 생성하고 연관 관계를 맺어주는 설정자를 사용함 (IoC, DI)

3) 리스코프 치환 원칙

- 인터페이스 규약을 맞춰서 구현해야 함
- 엑셀을 밟으면 무조건 앞으로 가도록 구현해야 함

4) 인터페이스 분리 원칙

- 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 나음
- 기능을 적절하게 쪼개는 것이 중요함
- 인터페이스가 명확해지고 대체 가능성이 높아짐

5) 의존관계 역전 원칙

- 추상화에 의존해야지 구체화에 의존하면 안된다
- 구현 클래스를 바라보지(의존하지) 말고, 인터페이스를 바라보아야(의존해야) 함
- 구현 클래스를 직접 선택하면 안됨

정리

- 객체 지향의 핵심은 다형성
- 다형성만으로는 쉽게 부품을 갈아 끼우듯이 개발 불가능 / 변경 시 클라이언트 코드도 함꼐 변경됨 / OCP, DIP 지킬 수 없음

---

# 객체 지향 설계와 스프링

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%2016.png)

![Untitled](S1%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20f6b0a4542795438aba9a7d92d8eaec0b/Untitled%2017.png)

미래에 확장 가능성이 있다면 추상적으로

변경 가능성이 없다면 구체화로 구현하는 것도 좋은 방법임